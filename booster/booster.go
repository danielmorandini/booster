package booster

import (
	"context"
	"fmt"
	"log"
	"net"
	"os"
	"os/signal"
	"strconv"
	"sync"

	"github.com/danielmorandini/booster/network"
	"github.com/danielmorandini/booster/network/packet"
	"github.com/danielmorandini/booster/node"
	"github.com/danielmorandini/booster/protocol"
	"github.com/danielmorandini/booster/pubsub"
	"github.com/danielmorandini/booster/socks5"
)

const TopicNodes = "topic_nodes"

// Proxy wraps that booster requires a proxy to implement.
type Proxy interface {
	// NotifyTunnel acts as a one time registration function. The returned channel
	// should produce messages that give intormation about the state of the tunnels
	// generated by the proxy.
	NotifyTunnel() (chan interface{}, error)

	// StopNotifying asks the receiver to stop generating tunnel notifications and
	// close the channel.
	StopNotifying(c chan interface{})

	// ListenAndServe should starts the actual proxy server, announcing it to the local
	// address.
	ListenAndServe(ctx context.Context, port int) error

	// Proto returns the string representation of the protocol used by the proxy.
	// Example: socks5.
	Proto() string
}

// PubSub describes the required functionalities of a publication/subscription object.
type PubSub interface {
	Sub(topic string) (chan interface{}, error)
	Unsub(c chan interface{}, topic string) error
	Pub(message interface{}, topic string) error
}

// Booster wraps the parts that compose a booster node together.
type Booster struct {
	*log.Logger

	Proxy Proxy
	PubSub

	mux     sync.Mutex
	Network *Network

	Netconfig network.Config
	stop      chan struct{}
}

// New creates a new configured booster node. Creates a network configuration
// based in the information contained in the protocol package.
//
// The internal proxy is configured to use the node dispatcher as network
// dialer.
func New(pport, bport int) (*Booster, error) {
	b := new(Booster)

	log := log.New(os.Stdout, "BOOSTER  ", log.LstdFlags)
	pubsub := pubsub.New()
	dialer := node.NewDispatcher(b)
	proxy := socks5.New(dialer)
	netconfig := network.Config{
		TagSet: packet.TagSet{
			PacketOpeningTag:  protocol.PacketOpeningTag,
			PacketClosingTag:  protocol.PacketClosingTag,
			PayloadClosingTag: protocol.PayloadClosingTag,
			Separator:         protocol.Separator,
		},
	}
	pp := strconv.Itoa(pport)
	bp := strconv.Itoa(bport)
	node, err := node.New("localhost", pp, bp, true)
	if err != nil {
		return nil, err
	}
	network := &Network{
		LocalNode: node,
		Conns:     []*Conn{},
	}

	b.Logger = log
	b.Proxy = proxy
	b.PubSub = pubsub
	b.Network = network
	b.Netconfig = netconfig
	b.stop = make(chan struct{})

	return b, nil
}

// Run starts the proxy and booster node.
//
// This is a blocking routine that can be stopped using the Close() method.
// Traps INTERRUPT signals.
func (b *Booster) Run() error {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	errc := make(chan error, 3)
	_, pport, _ := net.SplitHostPort(b.Network.LocalNode.PAddr.String())
	_, bport, _ := net.SplitHostPort(b.Network.LocalNode.BAddr.String())
	pp, _ := strconv.Atoi(pport)
	bp, _ := strconv.Atoi(bport)
	var wg sync.WaitGroup

	go func() {
		wg.Add(1)
		errc <- b.ListenAndServe(ctx, bp)
		wg.Done()
	}()

	go func() {
		wg.Add(1)
		errc <- b.Proxy.ListenAndServe(ctx, pp)
		wg.Done()
	}()

	go func() {
		wg.Add(1)
		errc <- b.UpdateRoot(ctx)
		wg.Done()
	}()

	// trap exit signals
	go func() {
		c := make(chan os.Signal, 1)
		signal.Notify(c, os.Interrupt)

		for sig := range c {
			b.Printf("booster: signal (%v) received: exiting...", sig)
			b.Close()
			return
		}
	}()

	select {
	case err := <-errc:
		cancel()
		wg.Wait()
		return err
	case <-b.stop:
		cancel()
		wg.Wait()
		return fmt.Errorf("booster: stopped")
	}
}

// Close stops the Run routine. It drops the whole booster network, preparing for the
// node to reset or stop.
func (b *Booster) Close() error {
	b.stop <- struct{}{}
	return nil
}

// ListenAndServe shows to the network, listening for incoming tcp connections an
// turning them into booster connections.
func (b *Booster) ListenAndServe(ctx context.Context, port int) error {
	p := strconv.Itoa(port)
	ln, err := network.Listen("tcp", ":"+p, b.Netconfig)
	if err != nil {
		return err
	}
	defer ln.Close()

	b.Printf("listening on port: %v", p)

	errc := make(chan error)
	defer close(errc)

	go func() {
		for {
			conn, err := ln.Accept()
			if err != nil {
				errc <- fmt.Errorf("booster: cannot accept conn: %v", err)
				return
			}

			go b.Handle(ctx, conn)
		}
	}()

	select {
	case err := <-errc:
		return err
	case <-ctx.Done():
		ln.Close()
		<-errc // wait for listener to return
		return ctx.Err()
	}
}

// Handle takes a network.Conn as input and listens for packets. As first step,
// it sends a Hello message to the receiver, together with all the information
// regarding this node.
func (b *Booster) Handle(ctx context.Context, conn *network.Conn) {
	defer conn.Close()

	// send hello message first.
	b.Printf("booster: -> sending hello message to %v", conn.RemoteAddr())
	if err := b.SendHello(ctx, conn); err != nil {
		b.Printf("booster: unable to hello: %v", err)
	}

	b.Printf("booster: <- hello sent!")

	// TODO(daniel): remove return and handle incoming packets
	return

	pkts, err := conn.Consume()
	if err != nil {
		b.Printf("booster: cannot consume packets: %v", err)
		return
	}

	b.Println("booster: consuming packets...")

	for p := range pkts {
		b.Printf("booster: consuming packet: %+v", p)
	}

	b.Println("booster: packets consumed.")
}

func (b *Booster) DialContext(ctx context.Context, netwk, addr string) (*Conn, error) {
	b.Printf("booster: starting dial procedure to %v", addr)

	dialer := network.NewDialer(new(net.Dialer), b.Netconfig)
	conn, err := dialer.DialContext(ctx, netwk, addr)
	if err != nil {
		return nil, err
	}

	return RecvHello(ctx, conn)
}

func (b *Booster) UpdateRoot(ctx context.Context) error {
	errc := make(chan error)
	c, err := b.Proxy.NotifyTunnel()
	if err != nil {
		return err
	}

	go b.updateRoot(c, errc)
	defer close(errc)

	select {
	case err := <-errc:
		return err
	case <-ctx.Done():
		b.Proxy.StopNotifying(c)
		return ctx.Err()
	}
}

func (b *Booster) updateRoot(c <-chan interface{}, errc chan error) {
	for i := range c {
		tm, ok := i.(socks5.TunnelMessage)
		if !ok {
			errc <- fmt.Errorf("unable to recognise workload message: %v", tm)
			return
		}

		target := tm.Target

		if tm.Event == socks5.EventPush {
			if err := b.Ack(b.Network.LocalNode, target); err != nil {
				b.Print(err)
				continue
			}
		}

		if tm.Event == socks5.EventPop {
			if err := b.RemoveTunnel(b.Network.LocalNode, target, true); err != nil {
				b.Print(err)
				continue
			}
		}
	}
}
