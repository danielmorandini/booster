// Code generated by protoc-gen-go. DO NOT EDIT.
// source: payload.proto

package internal

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/timestamp"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type PayloadHello struct {
	// bport is the booster listening port.
	Bport string `protobuf:"bytes,1,opt,name=bport" json:"bport,omitempty"`
	// pport is the proxy listening port.
	Pport string `protobuf:"bytes,2,opt,name=pport" json:"pport,omitempty"`
}

func (m *PayloadHello) Reset()                    { *m = PayloadHello{} }
func (m *PayloadHello) String() string            { return proto.CompactTextString(m) }
func (*PayloadHello) ProtoMessage()               {}
func (*PayloadHello) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

func (m *PayloadHello) GetBport() string {
	if m != nil {
		return m.Bport
	}
	return ""
}

func (m *PayloadHello) GetPport() string {
	if m != nil {
		return m.Pport
	}
	return ""
}

type PayloadConnect struct {
	// target of the connect procedure.
	Target string `protobuf:"bytes,1,opt,name=target" json:"target,omitempty"`
}

func (m *PayloadConnect) Reset()                    { *m = PayloadConnect{} }
func (m *PayloadConnect) String() string            { return proto.CompactTextString(m) }
func (*PayloadConnect) ProtoMessage()               {}
func (*PayloadConnect) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

func (m *PayloadConnect) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

type PayloadNode struct {
	// id is the identifier of the node. Usually a sha1 hash.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// baddr is the booster listening address.
	Baddr string `protobuf:"bytes,2,opt,name=baddr" json:"baddr,omitempty"`
	// paddr is the proxy listening address.
	Paddr string `protobuf:"bytes,3,opt,name=paddr" json:"paddr,omitempty"`
	// active tells the connection state of the node.
	Active bool `protobuf:"varint,4,opt,name=active" json:"active,omitempty"`
	// tunnels are the proxy tunnels managed by this node.
	Tunnels []*PayloadNode_Tunnel `protobuf:"bytes,5,rep,name=tunnels" json:"tunnels,omitempty"`
}

func (m *PayloadNode) Reset()                    { *m = PayloadNode{} }
func (m *PayloadNode) String() string            { return proto.CompactTextString(m) }
func (*PayloadNode) ProtoMessage()               {}
func (*PayloadNode) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

func (m *PayloadNode) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *PayloadNode) GetBaddr() string {
	if m != nil {
		return m.Baddr
	}
	return ""
}

func (m *PayloadNode) GetPaddr() string {
	if m != nil {
		return m.Paddr
	}
	return ""
}

func (m *PayloadNode) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

func (m *PayloadNode) GetTunnels() []*PayloadNode_Tunnel {
	if m != nil {
		return m.Tunnels
	}
	return nil
}

type PayloadNode_Tunnel struct {
	// id is the tunnel identifier. Usally a sha1 hash.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// target is the remote endpoint address of the tunnel.
	Target string `protobuf:"bytes,2,opt,name=target" json:"target,omitempty"`
	// acks is the number of acknoledgments on this tunnel.
	Acks int32 `protobuf:"varint,3,opt,name=acks" json:"acks,omitempty"`
	// copies are the replications of this tunnel.
	Copies int32 `protobuf:"varint,4,opt,name=copies" json:"copies,omitempty"`
}

func (m *PayloadNode_Tunnel) Reset()                    { *m = PayloadNode_Tunnel{} }
func (m *PayloadNode_Tunnel) String() string            { return proto.CompactTextString(m) }
func (*PayloadNode_Tunnel) ProtoMessage()               {}
func (*PayloadNode_Tunnel) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{2, 0} }

func (m *PayloadNode_Tunnel) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *PayloadNode_Tunnel) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

func (m *PayloadNode_Tunnel) GetAcks() int32 {
	if m != nil {
		return m.Acks
	}
	return 0
}

func (m *PayloadNode_Tunnel) GetCopies() int32 {
	if m != nil {
		return m.Copies
	}
	return 0
}

type PayloadHeartbeat struct {
	// id is the identifier of the heartbeat message. Should be unique.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// hops is the number of times that the heartbeat message has been reused.
	Hops int32 `protobuf:"varint,2,opt,name=hops" json:"hops,omitempty"`
	// ttl is the time to leave.
	Ttl *google_protobuf.Timestamp `protobuf:"bytes,3,opt,name=ttl" json:"ttl,omitempty"`
}

func (m *PayloadHeartbeat) Reset()                    { *m = PayloadHeartbeat{} }
func (m *PayloadHeartbeat) String() string            { return proto.CompactTextString(m) }
func (*PayloadHeartbeat) ProtoMessage()               {}
func (*PayloadHeartbeat) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{3} }

func (m *PayloadHeartbeat) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *PayloadHeartbeat) GetHops() int32 {
	if m != nil {
		return m.Hops
	}
	return 0
}

func (m *PayloadHeartbeat) GetTtl() *google_protobuf.Timestamp {
	if m != nil {
		return m.Ttl
	}
	return nil
}

func init() {
	proto.RegisterType((*PayloadHello)(nil), "internal.PayloadHello")
	proto.RegisterType((*PayloadConnect)(nil), "internal.PayloadConnect")
	proto.RegisterType((*PayloadNode)(nil), "internal.PayloadNode")
	proto.RegisterType((*PayloadNode_Tunnel)(nil), "internal.PayloadNode.Tunnel")
	proto.RegisterType((*PayloadHeartbeat)(nil), "internal.PayloadHeartbeat")
}

func init() { proto.RegisterFile("payload.proto", fileDescriptor1) }

var fileDescriptor1 = []byte{
	// 308 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x64, 0x91, 0xcf, 0x4b, 0xc3, 0x30,
	0x14, 0xc7, 0x69, 0xb7, 0xd6, 0xf9, 0xa6, 0x43, 0x82, 0x8c, 0x31, 0x04, 0x47, 0x4f, 0x3d, 0x48,
	0x06, 0x13, 0x3c, 0x78, 0xf5, 0xe2, 0x49, 0x24, 0xec, 0xe8, 0x25, 0x6d, 0xe2, 0x2c, 0x66, 0x4d,
	0x68, 0xdf, 0x04, 0xff, 0x72, 0xaf, 0xd2, 0x97, 0x44, 0x07, 0xbb, 0xe5, 0xfb, 0xed, 0xf7, 0xf5,
	0xf3, 0x7e, 0xc0, 0xa5, 0x93, 0xdf, 0xc6, 0x4a, 0xc5, 0x5d, 0x67, 0xd1, 0xb2, 0x49, 0xd3, 0xa2,
	0xee, 0x5a, 0x69, 0x96, 0xb7, 0x3b, 0x6b, 0x77, 0x46, 0xaf, 0xc9, 0xaf, 0x0e, 0xef, 0x6b, 0x6c,
	0xf6, 0xba, 0x47, 0xb9, 0x77, 0x3e, 0x5a, 0x3c, 0xc2, 0xc5, 0xab, 0xaf, 0x7d, 0xd6, 0xc6, 0x58,
	0x76, 0x0d, 0x59, 0xe5, 0x6c, 0x87, 0x8b, 0x64, 0x95, 0x94, 0xe7, 0xc2, 0x8b, 0xc1, 0x75, 0xe4,
	0xa6, 0xde, 0x25, 0x51, 0x94, 0x30, 0x0b, 0xb5, 0x4f, 0xb6, 0x6d, 0x75, 0x8d, 0x6c, 0x0e, 0x39,
	0xca, 0x6e, 0xa7, 0x63, 0x79, 0x50, 0xc5, 0x4f, 0x02, 0xd3, 0x10, 0x7d, 0xb1, 0x4a, 0xb3, 0x19,
	0xa4, 0x8d, 0x0a, 0x99, 0xb4, 0x51, 0x44, 0x95, 0x4a, 0x75, 0xf1, 0xff, 0x24, 0x88, 0x4a, 0xee,
	0x28, 0x50, 0xc9, 0x9d, 0x43, 0x2e, 0x6b, 0x6c, 0xbe, 0xf4, 0x62, 0xbc, 0x4a, 0xca, 0x89, 0x08,
	0x8a, 0x3d, 0xc0, 0x19, 0x1e, 0xda, 0x56, 0x9b, 0x7e, 0x91, 0xad, 0x46, 0xe5, 0x74, 0x73, 0xc3,
	0xe3, 0x1a, 0xf8, 0x11, 0x9b, 0x6f, 0x29, 0x24, 0x62, 0x78, 0xf9, 0x06, 0xb9, 0xb7, 0x4e, 0xba,
	0xfa, 0x9f, 0x26, 0x3d, 0x9e, 0x86, 0x31, 0x18, 0xcb, 0xfa, 0xb3, 0xa7, 0xb6, 0x32, 0x41, 0xef,
	0x21, 0x5b, 0x5b, 0xd7, 0xe8, 0x9e, 0xba, 0xca, 0x44, 0x50, 0x85, 0x82, 0xab, 0xbf, 0xfd, 0xca,
	0x0e, 0x2b, 0x2d, 0xf1, 0x84, 0xc3, 0x60, 0xfc, 0x61, 0x5d, 0x4f, 0x94, 0x4c, 0xd0, 0x9b, 0xdd,
	0xc1, 0x08, 0xd1, 0x10, 0x62, 0xba, 0x59, 0x72, 0x7f, 0x46, 0x1e, 0xcf, 0xc8, 0xb7, 0xf1, 0x8c,
	0x62, 0x88, 0x55, 0x39, 0x7d, 0xb8, 0xff, 0x0d, 0x00, 0x00, 0xff, 0xff, 0xa2, 0x29, 0x7f, 0x08,
	0x08, 0x02, 0x00, 0x00,
}
