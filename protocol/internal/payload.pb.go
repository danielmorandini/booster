// Code generated by protoc-gen-go. DO NOT EDIT.
// source: payload.proto

package internal

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/timestamp"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type PayloadCtrl struct {
	// operation is the operation that has to be performed.
	// See Ctrl operations in protocol.go
	Operation int32 `protobuf:"varint,1,opt,name=operation" json:"operation,omitempty"`
}

func (m *PayloadCtrl) Reset()                    { *m = PayloadCtrl{} }
func (m *PayloadCtrl) String() string            { return proto.CompactTextString(m) }
func (*PayloadCtrl) ProtoMessage()               {}
func (*PayloadCtrl) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

func (m *PayloadCtrl) GetOperation() int32 {
	if m != nil {
		return m.Operation
	}
	return 0
}

type PayloadBandwidth struct {
	// tot is the total number of bytes transmitted.
	Tot int64 `protobuf:"varint,1,opt,name=tot" json:"tot,omitempty"`
	// bandwidth is the current bandwidth.
	Bandwidth int64 `protobuf:"varint,2,opt,name=bandwidth" json:"bandwidth,omitempty"`
	// type is the transmission direction, i.e. dowload/upload
	Type string `protobuf:"bytes,3,opt,name=type" json:"type,omitempty"`
}

func (m *PayloadBandwidth) Reset()                    { *m = PayloadBandwidth{} }
func (m *PayloadBandwidth) String() string            { return proto.CompactTextString(m) }
func (*PayloadBandwidth) ProtoMessage()               {}
func (*PayloadBandwidth) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

func (m *PayloadBandwidth) GetTot() int64 {
	if m != nil {
		return m.Tot
	}
	return 0
}

func (m *PayloadBandwidth) GetBandwidth() int64 {
	if m != nil {
		return m.Bandwidth
	}
	return 0
}

func (m *PayloadBandwidth) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

type PayloadMonitor struct {
	// features contains the features that should be inspected.
	Features []int32 `protobuf:"varint,1,rep,packed,name=features" json:"features,omitempty"`
}

func (m *PayloadMonitor) Reset()                    { *m = PayloadMonitor{} }
func (m *PayloadMonitor) String() string            { return proto.CompactTextString(m) }
func (*PayloadMonitor) ProtoMessage()               {}
func (*PayloadMonitor) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

func (m *PayloadMonitor) GetFeatures() []int32 {
	if m != nil {
		return m.Features
	}
	return nil
}

type PayloadHello struct {
	// bport is the booster listening port.
	Bport string `protobuf:"bytes,1,opt,name=bport" json:"bport,omitempty"`
	// pport is the proxy listening port.
	Pport string `protobuf:"bytes,2,opt,name=pport" json:"pport,omitempty"`
}

func (m *PayloadHello) Reset()                    { *m = PayloadHello{} }
func (m *PayloadHello) String() string            { return proto.CompactTextString(m) }
func (*PayloadHello) ProtoMessage()               {}
func (*PayloadHello) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{3} }

func (m *PayloadHello) GetBport() string {
	if m != nil {
		return m.Bport
	}
	return ""
}

func (m *PayloadHello) GetPport() string {
	if m != nil {
		return m.Pport
	}
	return ""
}

type PayloadConnect struct {
	// target of the connect procedure.
	Target string `protobuf:"bytes,1,opt,name=target" json:"target,omitempty"`
}

func (m *PayloadConnect) Reset()                    { *m = PayloadConnect{} }
func (m *PayloadConnect) String() string            { return proto.CompactTextString(m) }
func (*PayloadConnect) ProtoMessage()               {}
func (*PayloadConnect) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{4} }

func (m *PayloadConnect) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

type PayloadDisconnect struct {
	// id is the identifier of the node that should be disconnected
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *PayloadDisconnect) Reset()                    { *m = PayloadDisconnect{} }
func (m *PayloadDisconnect) String() string            { return proto.CompactTextString(m) }
func (*PayloadDisconnect) ProtoMessage()               {}
func (*PayloadDisconnect) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{5} }

func (m *PayloadDisconnect) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type PayloadNode struct {
	// id is the identifier of the node. Usually a sha1 hash.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// baddr is the booster listening address.
	Baddr string `protobuf:"bytes,2,opt,name=baddr" json:"baddr,omitempty"`
	// paddr is the proxy listening address.
	Paddr string `protobuf:"bytes,3,opt,name=paddr" json:"paddr,omitempty"`
	// active tells the connection state of the node.
	Active bool `protobuf:"varint,4,opt,name=active" json:"active,omitempty"`
	// tunnels are the proxy tunnels managed by this node.
	Tunnels []*PayloadNode_Tunnel `protobuf:"bytes,5,rep,name=tunnels" json:"tunnels,omitempty"`
}

func (m *PayloadNode) Reset()                    { *m = PayloadNode{} }
func (m *PayloadNode) String() string            { return proto.CompactTextString(m) }
func (*PayloadNode) ProtoMessage()               {}
func (*PayloadNode) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{6} }

func (m *PayloadNode) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *PayloadNode) GetBaddr() string {
	if m != nil {
		return m.Baddr
	}
	return ""
}

func (m *PayloadNode) GetPaddr() string {
	if m != nil {
		return m.Paddr
	}
	return ""
}

func (m *PayloadNode) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

func (m *PayloadNode) GetTunnels() []*PayloadNode_Tunnel {
	if m != nil {
		return m.Tunnels
	}
	return nil
}

type PayloadNode_Tunnel struct {
	// id is the tunnel identifier. Usally a sha1 hash.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// target is the remote endpoint address of the tunnel.
	Target string `protobuf:"bytes,2,opt,name=target" json:"target,omitempty"`
	// copies are the replications of this tunnel.
	Copies int32 `protobuf:"varint,4,opt,name=copies" json:"copies,omitempty"`
}

func (m *PayloadNode_Tunnel) Reset()                    { *m = PayloadNode_Tunnel{} }
func (m *PayloadNode_Tunnel) String() string            { return proto.CompactTextString(m) }
func (*PayloadNode_Tunnel) ProtoMessage()               {}
func (*PayloadNode_Tunnel) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{6, 0} }

func (m *PayloadNode_Tunnel) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *PayloadNode_Tunnel) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

func (m *PayloadNode_Tunnel) GetCopies() int32 {
	if m != nil {
		return m.Copies
	}
	return 0
}

type PayloadHeartbeat struct {
	// id is the identifier of the heartbeat message. Should be unique.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// hops is the number of times that the heartbeat message has been reused.
	Hops int32 `protobuf:"varint,2,opt,name=hops" json:"hops,omitempty"`
	// ttl is the time to leave.
	Ttl *google_protobuf.Timestamp `protobuf:"bytes,3,opt,name=ttl" json:"ttl,omitempty"`
}

func (m *PayloadHeartbeat) Reset()                    { *m = PayloadHeartbeat{} }
func (m *PayloadHeartbeat) String() string            { return proto.CompactTextString(m) }
func (*PayloadHeartbeat) ProtoMessage()               {}
func (*PayloadHeartbeat) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{7} }

func (m *PayloadHeartbeat) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *PayloadHeartbeat) GetHops() int32 {
	if m != nil {
		return m.Hops
	}
	return 0
}

func (m *PayloadHeartbeat) GetTtl() *google_protobuf.Timestamp {
	if m != nil {
		return m.Ttl
	}
	return nil
}

type PayloadProxyUpdate struct {
	// target is the remote endpoint address of the tunnel.
	Target string `protobuf:"bytes,1,opt,name=target" json:"target,omitempty"`
	// operation is the action performed on the tunnel.
	Operation int32 `protobuf:"varint,2,opt,name=operation" json:"operation,omitempty"`
}

func (m *PayloadProxyUpdate) Reset()                    { *m = PayloadProxyUpdate{} }
func (m *PayloadProxyUpdate) String() string            { return proto.CompactTextString(m) }
func (*PayloadProxyUpdate) ProtoMessage()               {}
func (*PayloadProxyUpdate) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{8} }

func (m *PayloadProxyUpdate) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

func (m *PayloadProxyUpdate) GetOperation() int32 {
	if m != nil {
		return m.Operation
	}
	return 0
}

func init() {
	proto.RegisterType((*PayloadCtrl)(nil), "internal.PayloadCtrl")
	proto.RegisterType((*PayloadBandwidth)(nil), "internal.PayloadBandwidth")
	proto.RegisterType((*PayloadMonitor)(nil), "internal.PayloadMonitor")
	proto.RegisterType((*PayloadHello)(nil), "internal.PayloadHello")
	proto.RegisterType((*PayloadConnect)(nil), "internal.PayloadConnect")
	proto.RegisterType((*PayloadDisconnect)(nil), "internal.PayloadDisconnect")
	proto.RegisterType((*PayloadNode)(nil), "internal.PayloadNode")
	proto.RegisterType((*PayloadNode_Tunnel)(nil), "internal.PayloadNode.Tunnel")
	proto.RegisterType((*PayloadHeartbeat)(nil), "internal.PayloadHeartbeat")
	proto.RegisterType((*PayloadProxyUpdate)(nil), "internal.PayloadProxyUpdate")
}

func init() { proto.RegisterFile("payload.proto", fileDescriptor1) }

var fileDescriptor1 = []byte{
	// 426 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x92, 0x41, 0x6b, 0xdc, 0x30,
	0x10, 0x85, 0xb1, 0x1d, 0x6f, 0x77, 0x67, 0xdb, 0x90, 0x8a, 0x12, 0xcc, 0x12, 0xa8, 0x51, 0x2f,
	0x86, 0x06, 0x07, 0x52, 0xe8, 0xa1, 0xc7, 0xa6, 0x87, 0xa5, 0xd0, 0x12, 0x44, 0xda, 0xbb, 0xbc,
	0x52, 0x36, 0x02, 0x47, 0x12, 0xf2, 0x6c, 0xdb, 0xfd, 0xbd, 0xfd, 0x23, 0xc5, 0x63, 0xd9, 0x9b,
	0x26, 0xe4, 0xa6, 0xf7, 0xe9, 0x49, 0xf3, 0xa4, 0x19, 0x78, 0xe5, 0xe5, 0xbe, 0x75, 0x52, 0xd5,
	0x3e, 0x38, 0x74, 0x6c, 0x6e, 0x2c, 0xea, 0x60, 0x65, 0xbb, 0x7a, 0xbb, 0x75, 0x6e, 0xdb, 0xea,
	0x0b, 0xe2, 0xcd, 0xee, 0xf6, 0x02, 0xcd, 0xbd, 0xee, 0x50, 0xde, 0xfb, 0xc1, 0xca, 0xdf, 0xc3,
	0xf2, 0x7a, 0x38, 0x7b, 0x85, 0xa1, 0x65, 0x67, 0xb0, 0x70, 0x5e, 0x07, 0x89, 0xc6, 0xd9, 0x22,
	0x29, 0x93, 0x2a, 0x17, 0x07, 0xc0, 0x7f, 0xc2, 0x49, 0x34, 0x7f, 0x96, 0x56, 0xfd, 0x36, 0x0a,
	0xef, 0xd8, 0x09, 0x64, 0xe8, 0x90, 0xbc, 0x99, 0xe8, 0x97, 0xfd, 0x1d, 0xcd, 0xb8, 0x5d, 0xa4,
	0xc4, 0x0f, 0x80, 0x31, 0x38, 0xc2, 0xbd, 0xd7, 0x45, 0x56, 0x26, 0xd5, 0x42, 0xd0, 0x9a, 0x9f,
	0xc3, 0x71, 0xbc, 0xf7, 0x9b, 0xb3, 0x06, 0x5d, 0x60, 0x2b, 0x98, 0xdf, 0x6a, 0x89, 0xbb, 0xa0,
	0xbb, 0x22, 0x29, 0xb3, 0x2a, 0x17, 0x93, 0xe6, 0x9f, 0xe0, 0x65, 0x74, 0xaf, 0x75, 0xdb, 0x3a,
	0xf6, 0x06, 0xf2, 0xc6, 0xbb, 0x30, 0x64, 0x58, 0x88, 0x41, 0xf4, 0xd4, 0x13, 0x4d, 0x07, 0x4a,
	0x82, 0x57, 0x53, 0xa5, 0x2b, 0x67, 0xad, 0xde, 0x20, 0x3b, 0x85, 0x19, 0xca, 0xb0, 0xd5, 0xe3,
	0xf1, 0xa8, 0xf8, 0x3b, 0x78, 0x1d, 0x9d, 0x5f, 0x4c, 0xb7, 0x89, 0xe6, 0x63, 0x48, 0x8d, 0x8a,
	0xc6, 0xd4, 0x28, 0xfe, 0x37, 0x99, 0xbe, 0xef, 0xbb, 0x53, 0xfa, 0xf1, 0x3e, 0x45, 0x93, 0x4a,
	0x85, 0x31, 0x04, 0x09, 0x8a, 0x46, 0x34, 0x8b, 0xd1, 0x88, 0x9e, 0xc2, 0x4c, 0x6e, 0xd0, 0xfc,
	0xd2, 0xc5, 0x51, 0x99, 0x54, 0x73, 0x11, 0x15, 0xfb, 0x08, 0x2f, 0x70, 0x67, 0xad, 0x6e, 0xbb,
	0x22, 0x2f, 0xb3, 0x6a, 0x79, 0x79, 0x56, 0x8f, 0xed, 0xad, 0x1f, 0xd4, 0xae, 0x6f, 0xc8, 0x24,
	0x46, 0xf3, 0x6a, 0x0d, 0xb3, 0x01, 0x3d, 0x49, 0x75, 0x78, 0x72, 0xfa, 0xf0, 0xc9, 0x3d, 0xdf,
	0x38, 0x6f, 0x74, 0x47, 0x09, 0x72, 0x11, 0x15, 0x57, 0x53, 0xdb, 0xd7, 0x5a, 0x06, 0x6c, 0xb4,
	0x7c, 0xf2, 0x13, 0x7d, 0x5b, 0xef, 0x9c, 0xef, 0xe8, 0xc6, 0x5c, 0xd0, 0x9a, 0x9d, 0x43, 0x86,
	0xd8, 0xd2, 0x2b, 0x97, 0x97, 0xab, 0x7a, 0x18, 0xc5, 0x7a, 0x1c, 0xc5, 0xfa, 0x66, 0x1c, 0x45,
	0xd1, 0xdb, 0xf8, 0x57, 0x60, 0xb1, 0xca, 0x75, 0x70, 0x7f, 0xf6, 0x3f, 0xbc, 0x92, 0xa8, 0x9f,
	0x6b, 0xcf, 0xff, 0x83, 0x9a, 0x3e, 0x1a, 0xd4, 0x66, 0x46, 0x45, 0x3e, 0xfc, 0x0b, 0x00, 0x00,
	0xff, 0xff, 0x63, 0x7c, 0xef, 0x48, 0x18, 0x03, 0x00, 0x00,
}
